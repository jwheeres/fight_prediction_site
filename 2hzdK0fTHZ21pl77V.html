<html><head><base href="." />
<style>
:root {
  --ufc-red: #FFD700;
  --ufc-black: #111111;
}

@import url('https://fonts.googleapis.com/css2?family=Söhne:wght@400;500;600;700&display=swap');

body {
  font-family: Söhne, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Ubuntu, Cantarell, "Noto Sans", sans-serif, "Helvetica Neue", Arial;
  margin: 0;
  padding: 20px;
  background: var(--ufc-black);
  color: white;
  position: relative;
  overflow: hidden;
}

body::before {
  content: '';
  position: fixed;
  top: 0;
  left: 0;
  width: 200%;
  height: 200%;
  background: repeating-linear-gradient(
    45deg,
    var(--ufc-black) 0%,
    var(--ufc-black) 10%,
    rgba(210, 10, 10, 0.1) 10%,
    rgba(210, 10, 10, 0.1) 20%
  );
  animation: backgroundMove 20s linear infinite;
  z-index: -3;
}

/* Add new matrix container */
.matrix-background {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: -2;
  opacity: 0.15;
  pointer-events: none;
}

.matrix-column {
  position: absolute;
  top: -1000px;
  width: 20px;
  color: rgba(255, 255, 255, 0.7); /* Increased opacity from 0.6 */
  font-size: 12px;
  font-family: monospace;
  white-space: nowrap;
  transform: translateZ(0);
}

/* Neural network animation background */
body::after {
  content: '';
  position: fixed;
  top: 0;
  left: 0;
  width: 200%;
  height: 200%;
  background: 
    radial-gradient(
      1px 1px at 50px 50px,
      rgba(255, 255, 255, 0.15) 50%,
      transparent 50%
    ),
    radial-gradient(
      1px 1px at 100px 150px,
      rgba(255, 255, 255, 0.15) 50%,
      transparent 50%
    ),
    radial-gradient(
      1px 1px at 150px 50px,
      rgba(255, 255, 255, 0.15) 50%,
      transparent 50%
    ),
    radial-gradient(
      1px 1px at 200px 200px,
      rgba(255, 255, 255, 0.15) 50%,
      transparent 50%
    ),
    repeating-linear-gradient(
      to right,
      transparent 0%,
      transparent 45%,
      rgba(255, 255, 255, 0.03) 45%,
      rgba(255, 255, 255, 0.03) 47%,
      transparent 47%,
      transparent 53%,
      rgba(255, 255, 255, 0.03) 53%,
      rgba(255, 255, 255, 0.03) 55%,
      transparent 55%
    ),
    repeating-linear-gradient(
      45deg,
      transparent 0%,
      transparent 45%,
      rgba(255, 255, 255, 0.03) 45%,
      rgba(255, 255, 255, 0.03) 47%,
      transparent 47%,
      transparent 53%,
      rgba(255, 255, 255, 0.03) 53%,
      rgba(255, 255, 255, 0.03) 55%,
      transparent 55%
    ),
    repeating-linear-gradient(
      -45deg,
      transparent 0%,
      transparent 45%,
      rgba(255, 255, 255, 0.03) 45%,
      rgba(255, 255, 255, 0.03) 47%,
      transparent 47%,
      transparent 53%,
      rgba(255, 255, 255, 0.03) 53%,
      rgba(255, 255, 255, 0.03) 55%,
      transparent 55%
    );
  background-size: 200px 200px;
  animation: neuralNetMove 15s ease-in-out infinite;
  z-index: -1;
  opacity: 0.7;
  filter: blur(0.5px);
}

@keyframes backgroundMove {
  0% {
    transform: translate(-50%, -50%) rotate(0deg);
  }
  100% {
    transform: translate(-50%, -50%) rotate(360deg);
  }
}

@keyframes neuralNetMove {
  0% {
    transform: translate(-50%, -50%) scale(1) rotate(0deg);
    background-size: 200px 200px;
    opacity: 0.5;
  }
  25% {
    transform: translate(-45%, -45%) scale(1.2) rotate(2deg);
    background-size: 250px 250px;
    opacity: 0.7;
  }
  50% {
    transform: translate(-50%, -50%) scale(1.5) rotate(-2deg);
    background-size: 300px 300px;
    opacity: 0.9;
  }
  75% {
    transform: translate(-55%, -55%) scale(1.2) rotate(1deg);
    background-size: 250px 250px;
    opacity: 0.7;
  }
  100% {
    transform: translate(-50%, -50%) scale(1) rotate(0deg);
    background-size: 200px 200px;
    opacity: 0.5;
  }
}

.container {
  position: relative;
  z-index: 1;
  backdrop-filter: blur(5px);
  max-width: 800px;
  margin: 0 auto;
}

.logo {
  text-align: center;
  margin-bottom: 20px;
}

.logo-container {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 5px; /* Reduced from 15px */
}

.three-eyes {
  position: relative;
}

.eye .eyelid {
  animation: blink 4s infinite;
  transform-origin: center;
}

.eye:nth-child(2) .eyelid {
  animation-delay: 1.5s;
}

.eye:nth-child(3) .eyelid {
  animation-delay: 2.7s;
}

@keyframes blink {
  0%, 95%, 100% {
    transform: scaleY(0);
  }
  97% {
    transform: scaleY(1);
  }
}

.pupil {
  animation: pupilMove 6s ease-in-out infinite;
}

.eye:nth-child(2) .pupil {
  animation-delay: 1s;
}

.eye:nth-child(3) .pupil {
  animation-delay: 2s;
}

@keyframes pupilMove {
  0%, 100% {
    transform: translate(0, 0);
  }
  25% {
    transform: translate(2px, -2px);
  }
  50% {
    transform: translate(-2px, 2px);
  }
  75% {
    transform: translate(2px, 2px);
  }
}

.fight-predictor {
  background: rgba(255,255,255,0.1);
  padding: 20px;
  border-radius: 10px;
  margin-bottom: 20px;
}

.fighter-select {
  display: flex;
  justify-content: space-between;
  gap: 20px;
  margin-bottom: 20px;
}

.fighter {
  flex: 1;
  text-align: center;
}

input[type="text"] {
  width: 100%;
  padding: 10px;
  background: var(--ufc-black);
  color: white;
  border: 2px solid var(--ufc-red);
  border-radius: 5px;
  margin-top: 10px;
}

input[type="text"]::placeholder {
  color: rgba(255,255,255,0.5);
}

button {
  background: var(--ufc-red);
  color: white;
  border: none;
  padding: 15px 30px;
  border-radius: 5px;
  font-weight: bold;
  cursor: pointer;
  width: 100%;
  font-size: 18px;
  text-transform: uppercase;
}

button:hover {
  background: #ff0000;
}

.prediction-result {
  margin-top: 20px;
  padding: 20px;
  border: 2px solid var(--ufc-red);
  border-radius: 5px;
  display: none;
}

.loading {
  text-align: center;
  display: none;
}

.octagon-spinner {
  width: 50px;
  height: 50px;
  animation: spin 1s linear infinite;
  margin: 20px auto;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.stats-comparison {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 20px;
  margin-top: 20px;
}

.stat-item {
  background: rgba(255,255,255,0.05);
  padding: 10px;
  border-radius: 5px;
}

/* Remove audio player related styles */
.audio-player,
.visualizer-container,
.audio-controls,
.play-pause,
.progress-bar,
.time-display {
  display: none;
}
</style>
<link href="https://fonts.googleapis.com/css2?family=Roboto+Condensed:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
<div class="matrix-background" id="matrix"></div>
<div class="container">
  <div class="logo">
    <div class="logo-container">
      <svg class="three-eyes" width="50" height="40" viewBox="0 0 50 40">
        <g class="eye" transform="translate(2, 20)">
          <circle class="eye-outline" cx="10" cy="0" r="8" fill="none" stroke="var(--ufc-red)" stroke-width="2"/>
          <circle class="eyelid" cx="10" cy="0" r="8" fill="var(--ufc-black)"/>
          <circle class="pupil" cx="10" cy="0" r="4" fill="var(--ufc-red)"/>
        </g>
        <g class="eye" transform="translate(18, 20)">
          <circle class="eye-outline" cx="10" cy="0" r="8" fill="none" stroke="var(--ufc-red)" stroke-width="2"/>
          <circle class="eyelid" cx="10" cy="0" r="8" fill="var(--ufc-black)"/>
          <circle class="pupil" cx="10" cy="0" r="4" fill="var(--ufc-red)"/>
        </g>
        <g class="eye" transform="translate(34, 20)">
          <circle class="eye-outline" cx="10" cy="0" r="8" fill="none" stroke="var(--ufc-red)" stroke-width="2"/>
          <circle class="eyelid" cx="10" cy="0" r="8" fill="var(--ufc-black)"/>
          <circle class="pupil" cx="10" cy="0" r="4" fill="var(--ufc-red)"/>
        </g>
      </svg>
      <svg width="160" height="40" viewBox="0 0 160 40" style="margin-left: -10px;">
        <text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" 
              fill="var(--ufc-red)" font-size="20" font-weight="bold" font-family="Söhne">
          QUALIA BETS
        </text>
      </svg>
    </div>
  </div>

  <div class="fight-predictor">
    <div class="fighter-select">
      <div class="fighter">
        <h3>Fighter 1</h3>
        <input type="text" id="fighter1" list="fighterList1" placeholder="Search fighter...">
        <datalist id="fighterList1"></datalist>
      </div>
      <div class="fighter">
        <h3>Fighter 2</h3>
        <input type="text" id="fighter2" list="fighterList2" placeholder="Search fighter...">
        <datalist id="fighterList2"></datalist>
      </div>
    </div>

    <button onclick="predictFight()">Predict Fight</button>

    <div class="loading" id="loading">
      <svg class="octagon-spinner" viewBox="0 0 100 100">
        <polygon points="50,0 85,15 100,50 85,85 50,100 15,85 0,50 15,15" 
                 fill="none" stroke="var(--ufc-red)" stroke-width="8"/>
      </svg>
      <p>Analyzing fight data...</p>
    </div>

    <div class="prediction-result" id="prediction">
      <h2>Fight Prediction</h2>
      <div id="prediction-text"></div>
      <div class="stats-comparison" id="stats-comparison"></div>
    </div>
  </div>
</div>

<script>
// Comprehensive UFC fighter database
const fighters = {
  // Heavyweight
  "Jon Jones": { wins: 27, losses: 1, knockouts: 10, submissions: 7, takedowns: 95, striking_accuracy: 0.76 },
  "Ciryl Gane": { wins: 11, losses: 2, knockouts: 5, submissions: 3, takedowns: 40, striking_accuracy: 0.78 },
  "Sergei Pavlovich": { wins: 18, losses: 1, knockouts: 15, submissions: 1, takedowns: 25, striking_accuracy: 0.72 },
  "Tom Aspinall": { wins: 13, losses: 3, knockouts: 10, submissions: 3, takedowns: 35, striking_accuracy: 0.70 },
  
  // Light Heavyweight
  "Jamahal Hill": { wins: 12, losses: 1, knockouts: 7, submissions: 0, takedowns: 15, striking_accuracy: 0.75 },
  "Magomed Ankalaev": { wins: 18, losses: 1, knockouts: 9, submissions: 1, takedowns: 45, striking_accuracy: 0.72 },
  "Jiri Prochazka": { wins: 29, losses: 3, knockouts: 25, submissions: 3, takedowns: 30, striking_accuracy: 0.68 },
  
  // Middleweight
  "Israel Adesanya": { wins: 24, losses: 2, knockouts: 16, submissions: 0, takedowns: 15, striking_accuracy: 0.80 },
  "Sean Strickland": { wins: 27, losses: 5, knockouts: 11, submissions: 4, takedowns: 40, striking_accuracy: 0.71 },
  "Dricus Du Plessis": { wins: 19, losses: 2, knockouts: 9, submissions: 8, takedowns: 35, striking_accuracy: 0.69 },
  
  // Welterweight
  "Leon Edwards": { wins: 21, losses: 3, knockouts: 7, submissions: 3, takedowns: 55, striking_accuracy: 0.74 },
  "Kamaru Usman": { wins: 20, losses: 3, knockouts: 9, submissions: 1, takedowns: 100, striking_accuracy: 0.76 },
  "Belal Muhammad": { wins: 22, losses: 3, knockouts: 5, submissions: 1, takedowns: 75, striking_accuracy: 0.73 },
  
  // Lightweight
  "Islam Makhachev": { wins: 24, losses: 1, knockouts: 4, submissions: 11, takedowns: 110, striking_accuracy: 0.73 },
  "Charles Oliveira": { wins: 33, losses: 9, knockouts: 9, submissions: 21, takedowns: 45, striking_accuracy: 0.71 },
  "Justin Gaethje": { wins: 24, losses: 4, knockouts: 19, submissions: 1, takedowns: 25, striking_accuracy: 0.70 },
  
  // Featherweight
  "Alexander Volkanovski": { wins: 25, losses: 3, knockouts: 13, submissions: 3, takedowns: 65, striking_accuracy: 0.79 },
  "Yair Rodriguez": { wins: 15, losses: 4, knockouts: 6, submissions: 3, takedowns: 30, striking_accuracy: 0.75 },
  "Ilia Topuria": { wins: 14, losses: 0, knockouts: 4, submissions: 8, takedowns: 40, striking_accuracy: 0.72 },
  
  // Bantamweight
  "Sean O'Malley": { wins: 17, losses: 1, knockouts: 12, submissions: 1, takedowns: 15, striking_accuracy: 0.82 },
  "Aljamain Sterling": { wins: 23, losses: 4, knockouts: 3, submissions: 8, takedowns: 90, striking_accuracy: 0.71 },
  "Merab Dvalishvili": { wins: 16, losses: 4, knockouts: 2, submissions: 3, takedowns: 120, striking_accuracy: 0.68 },
  
  // Flyweight
  "Alexandre Pantoja": { wins: 26, losses: 5, knockouts: 8, submissions: 9, takedowns: 45, striking_accuracy: 0.73 },
  "Brandon Moreno": { wins: 21, losses: 7, knockouts: 5, submissions: 11, takedowns: 40, striking_accuracy: 0.74 },
  "Brandon Royval": { wins: 15, losses: 6, knockouts: 3, submissions: 9, takedowns: 35, striking_accuracy: 0.70 },
  
  // Women's Divisions
  "Alexa Grasso": { wins: 16, losses: 3, knockouts: 4, submissions: 4, takedowns: 35, striking_accuracy: 0.75 },
  "Valentina Shevchenko": { wins: 23, losses: 4, knockouts: 8, submissions: 7, takedowns: 60, striking_accuracy: 0.78 },
  "Zhang Weili": { wins: 23, losses: 3, knockouts: 11, submissions: 7, takedowns: 50, striking_accuracy: 0.76 },
  "Amanda Nunes": { wins: 22, losses: 5, knockouts: 13, submissions: 4, takedowns: 45, striking_accuracy: 0.72 }
};

// Populate fighter datalists
function populateFighters() {
  const datalist1 = document.getElementById('fighterList1');
  const datalist2 = document.getElementById('fighterList2');
  
  for (let fighter in fighters) {
    const option1 = document.createElement('option');
    const option2 = document.createElement('option');
    option1.value = fighter;
    option2.value = fighter;
    datalist1.appendChild(option1);
    datalist2.appendChild(option2);
  }
}

// Predict fight outcome
function predictFight() {
  const fighter1Name = document.getElementById('fighter1').value;
  const fighter2Name = document.getElementById('fighter2').value;

  if (!fighter1Name || !fighter2Name) {
    alert('Please select both fighters');
    return;
  }

  if (fighter1Name === fighter2Name) {
    alert('Please select different fighters');
    return;
  }

  if (!fighters[fighter1Name] || !fighters[fighter2Name]) {
    alert('Please select valid fighters from the list');
    return;
  }

  const loading = document.getElementById('loading');
  const prediction = document.getElementById('prediction');
  loading.style.display = 'block';
  prediction.style.display = 'none';

  // Simulate API delay
  setTimeout(() => {
    const fighter1 = fighters[fighter1Name];
    const fighter2 = fighters[fighter2Name];

    // Simple prediction algorithm
    const fighter1Score = calculateFighterScore(fighter1);
    const fighter2Score = calculateFighterScore(fighter2);

    const predictionText = document.getElementById('prediction-text');
    const winner = fighter1Score > fighter2Score ? fighter1Name : fighter2Name;
    const winProbability = Math.round(Math.abs(fighter1Score - fighter2Score) * 10);

    predictionText.innerHTML = `
      <h3>${winner} is predicted to win with ${winProbability}% confidence</h3>
      <p>Based on historical performance and fighting statistics</p>
    `;

    // Display stats comparison
    displayStatsComparison(fighter1Name, fighter2Name, fighter1, fighter2);

    loading.style.display = 'none';
    prediction.style.display = 'block';
  }, 2000);
}

function calculateFighterScore(fighter) {
  return (
    (fighter.wins / (fighter.wins + fighter.losses)) * 0.3 +
    (fighter.knockouts / fighter.wins) * 0.2 +
    (fighter.submissions / fighter.wins) * 0.2 +
    (fighter.takedowns / 100) * 0.15 +
    fighter.striking_accuracy * 0.15
  );
}

function displayStatsComparison(name1, name2, fighter1, fighter2) {
  const statsComparison = document.getElementById('stats-comparison');
  statsComparison.innerHTML = `
    <div class="stat-item">
      <h4>${name1}</h4>
      <p>Record: ${fighter1.wins}-${fighter1.losses}</p>
      <p>KOs: ${fighter1.knockouts}</p>
      <p>Submissions: ${fighter1.submissions}</p>
      <p>Takedowns: ${fighter1.takedowns}</p>
      <p>Striking Accuracy: ${(fighter1.striking_accuracy * 100).toFixed(1)}%</p>
    </div>
    <div class="stat-item">
      <h4>${name2}</h4>
      <p>Record: ${fighter2.wins}-${fighter2.losses}</p>
      <p>KOs: ${fighter2.knockouts}</p>
      <p>Submissions: ${fighter2.submissions}</p>
      <p>Takedowns: ${fighter2.takedowns}</p>
      <p>Striking Accuracy: ${(fighter2.striking_accuracy * 100).toFixed(1)}%</p>
    </div>
  `;
}

// Matrix rain effect
function createMatrixRain() {
  const matrix = document.getElementById('matrix');
  const width = window.innerWidth;
  const columns = Math.floor(width / 20);
  
  const characters = '01';
  
  function createColumn() {
    const column = document.createElement('div');
    column.className = 'matrix-column';
    column.style.left = Math.random() * width + 'px';
    
    // Increase speed by reducing the base speed value
    let speed = 30 + Math.random() * 30; // Changed from 50 + Math.random() * 50
    let length = 20 + Math.floor(Math.random() * 30);
    let y = -1000;
    
    function animate() {
      let text = '';
      for(let i = 0; i < length; i++) {
        text += characters.charAt(Math.floor(Math.random() * characters.length)) + '<br>';
      }
      column.innerHTML = text;
      column.style.transform = `translateY(${y}px)`;
      // Increase movement speed
      y += 15; // Changed from 10
      
      if(y > window.innerHeight + 1000) {
        y = -1000;
        column.style.left = Math.random() * width + 'px';
      }
      
      setTimeout(animate, speed);
    }
    
    animate();
    return column;
  }
  
  // Create more columns by increasing the divisor
  for(let i = 0; i < columns/2; i++) { // Changed from columns/3
    matrix.appendChild(createColumn());
  }
}

// Initialize
populateFighters();
window.addEventListener('load', createMatrixRain);
window.addEventListener('resize', () => {
  const matrix = document.getElementById('matrix');
  matrix.innerHTML = '';
  createMatrixRain();
});

// Enhanced Matrix animation
class EnhancedMatrixAnimation {
  constructor() {
    this.canvas = document.createElement('canvas');
    this.canvas.id = 'matrixCanvas';
    this.canvas.style.position = 'fixed';
    this.canvas.style.top = '0';
    this.canvas.style.left = '0';
    this.canvas.style.width = '100%';
    this.canvas.style.height = '100%';
    this.canvas.style.zIndex = '-1';
    document.body.appendChild(this.canvas);
    
    this.ctx = this.canvas.getContext('2d');
    this.symbols = '01';
    this.particles = [];
    this.timestamp = 0;
    
    this.resize();
    window.addEventListener('resize', () => this.resize());
    this.animate();
  }

  resize() {
    this.canvas.width = window.innerWidth;
    this.canvas.height = window.innerHeight;
    this.initParticles();
  }

  initParticles() {
    this.particles = [];
    const particleCount = Math.floor((this.canvas.width * this.canvas.height) / 2000);
    
    for (let i = 0; i < particleCount; i++) {
      this.particles.push({
        x: Math.random() * this.canvas.width,
        y: Math.random() * this.canvas.height,
        speed: 2 + Math.random() * 4,
        size: 8 + Math.random() * 8,
        angle: Math.random() * Math.PI * 2,
        rotation: (Math.random() - 0.5) * 0.1,
        chaos: Math.random() * 0.5
      });
    }
  }

  animate(timestamp) {
    this.timestamp = timestamp;
    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

    const centerX = this.canvas.width / 2;
    const centerY = this.canvas.height / 2;
    const maxRadius = Math.min(this.canvas.width, this.canvas.height) * 0.45;

    // Draw erratic circular patterns
    for (let i = 0; i < 12; i++) {
      const time = timestamp / 1000;
      const radius = maxRadius * (0.7 + Math.sin(time * 0.5 + i) * 0.3);
      const angleOffset = Math.sin(time * 2 + i) * 0.5;
      
      for (let angle = 0; angle < Math.PI * 2; angle += 0.02) {
        const x = centerX + Math.cos(angle + angleOffset) * (radius + Math.sin(time * 3 + angle * 5) * 50);
        const y = centerY + Math.sin(angle + angleOffset) * (radius + Math.cos(time * 3 + angle * 5) * 50);
        
        const char = this.symbols[Math.floor(Math.random() * this.symbols.length)];
        const opacity = 0.3 + Math.sin(time + angle * 3) * 0.2;
        
        this.ctx.font = '12px monospace';
        this.ctx.fillStyle = `rgba(255, 0, 0, ${opacity})`;
        this.ctx.fillText(char, x, y);
      }
    }

    // Update and draw particles
    this.particles.forEach(particle => {
      particle.angle += particle.rotation + Math.sin(timestamp * 0.001) * particle.chaos;
      particle.x += Math.cos(particle.angle) * particle.speed;
      particle.y += Math.sin(particle.angle) * particle.speed;

      // Wrap around screen
      if (particle.x < 0) particle.x = this.canvas.width;
      if (particle.x > this.canvas.width) particle.x = 0;
      if (particle.y < 0) particle.y = this.canvas.height;
      if (particle.y > this.canvas.height) particle.y = 0;

      const char = this.symbols[Math.floor(Math.random() * this.symbols.length)];
      const opacity = 0.4 + Math.sin(timestamp * 0.001 + particle.x * 0.01) * 0.2;
      
      this.ctx.font = `${particle.size}px monospace`;
      this.ctx.fillStyle = `rgba(255, 0, 0, ${opacity})`;
      this.ctx.fillText(char, particle.x, particle.y);
    });

    requestAnimationFrame((t) => this.animate(t));
  }
}

// Initialize animation on page load
document.addEventListener('DOMContentLoaded', () => {
  new EnhancedMatrixAnimation();
});
</script>
</body></html>